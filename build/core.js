// Generated by LiveScript 1.3.1
(function(){
  var ref$, flip, any, lines, unlines, words, unwords, apply, fold1, map2, push, pull, unite, includes, test, encode64, decode64, substr, supstr, matchAll, replaceAll, compose, repeatFn, repeatFn1, repeatFn2, slice$ = [].slice;
  ref$ = require('prelude-ls'), flip = ref$.flip, any = ref$.any, lines = ref$.lines, unlines = ref$.unlines, words = ref$.words, unwords = ref$.unwords, apply = ref$.apply, fold1 = ref$.fold1;
  map2 = curry$(function(f, xs){
    var i$, len$, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      results$.push((fn$.call(this, xs[i$])));
    }
    return results$;
    function fn$(x){
      return f(x);
    }
  });
  push = curry$(function(arr, el){
    return arr.concat(el);
  });
  pull = curry$(function(arr, el){
    return [el].concat(arr);
  });
  unite = curry$(function(arr1, arr2){
    return arr1.concat(arr2);
  });
  includes = curry$(function(xs, x){
    return in$(x, xs);
  });
  test = curry$(function(rx, str){
    return rx.test(str);
  });
  encode64 = function(str){
    var a;
    a = new Buffer(str);
    return a.toString('base64');
  };
  decode64 = function(str64){
    var a;
    a = new Buffer(str64, 'base64');
    return a.toString();
  };
  substr = curry$(function(sub, str){
    return 0 <= str.indexOf(sub);
  });
  supstr = flip(substr);
  matchAll = curry$(function(re, str){
    var flags, rx, matches, hit;
    flags = 'g';
    if (re.ignoreCase) {
      flags += 'i';
    }
    if (re.multiline) {
      flags += 'm';
    }
    rx = new RegExp(re.source, flags);
    matches = [];
    while (hit = rx.exec(str)) {
      matches = push(matches, hit[1]);
    }
    return matches;
  });
  replaceAll = curry$(function(rx, sub, str){
    var strMatrix;
    strMatrix = map2(words)(
    lines(
    str));
    while (any(any(partialize$.apply(rx, [rx.test, [void 8], [0]])), strMatrix)) {
      strMatrix = map2(map2(fn$), strMatrix);
    }
    return unlines(
    map2(unwords)(
    strMatrix));
    function fn$(it){
      return it.replace(rx, sub);
    }
  });
  compose = function(){
    var fs, composeTwo;
    fs = slice$.call(arguments);
    composeTwo = function(f, g){
      return compose$(g, f);
    };
    return fold1(composeTwo, fs);
  };
  repeatFn = curry$(function(t, f, args){
    var fn;
    fn = function(){
      setTimeout(fn, t);
      return apply(f, args);
    };
    return fn();
  });
  repeatFn1 = function(t, f){
    var args, fn;
    args = slice$.call(arguments, 2);
    fn = function(){
      setTimeout(fn, t);
      return f.apply(null, args);
    };
    return fn();
  };
  repeatFn2 = curry$(function(t, f, n, args){
    var fn;
    fn = function(){
      setTimeout(fn, t);
      console.log("Beginning new loop for " + n);
      return apply(f, args);
    };
    return fn();
  });
  import$(module.exports, require('prelude-ls'));
  module.exports = {
    map2: map2,
    push: push,
    pull: pull,
    unite: unite,
    includes: includes,
    test: test,
    encode64: encode64,
    decode64: decode64,
    substr: substr,
    supstr: supstr,
    matchAll: matchAll,
    replaceAll: replaceAll,
    compose: compose,
    repeatFn: repeatFn,
    repeatFn1: repeatFn1,
    repeatFn2: repeatFn2
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function partialize$(f, args, where){
    var context = this;
    return function(){
      var params = slice$.call(arguments), i,
          len = params.length, wlen = where.length,
          ta = args ? args.concat() : [], tw = where ? where.concat() : [];
      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
      return len < wlen && len ?
        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
    };
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
